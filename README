## Usage

Takes one filename argument (defaults to "rosalind_long.txt") and
prints assembled superstring to stdout. Mark executable or run with
`python3 rosalind.py`.


## Caveats

`find_overlap` assumes (without loss of correctness) that left and
right are roughly the same length, but if the left string is
significantly longer, complexity is linear in len(left) but remains
O(min_overlap) if right is significantly longer. Superstring
relationships are not detected.

A possible optimization is ignored in adjecency_list: After a match is
found for a left or right is found, we could stop checking those and
reduce the number of calls to find_overlap (the most expensive method)
by at least 50% (~75% on average). I tried this and didn't like the
code or see significance performance increase compared to the overhead
of running the entire program.

`adjacency_list` is not technically an adjacency list, whose type
would be `String -> List[String]` rather than `String -> String`. This
is fine for our case, where the path through the graph is acyclic and
unique.

I could return some sort of overlap object/tuple/datastructure that
stores the length of overlap, rather than just a string, so I don't
have to recompute overlap during assembly. I don't for two reasons:

 - find_overlap is only called O(N) times during assembly, vs O(N^2)
   times during adjacency. Not likely to make 1% difference.

 - By not overdesigning for this special-case optimization, code is
   cleaner, more intuitive, and more re-useable.

I call `find_overlap` in `assemble` without first performing a None
check. This is safe, because of the pre-computed `adj`, but the compiler
doesn't know that. Living on the edge! ;)
