## Usage

Takes one filename argument (defaults to "rosalind_long.txt") and
prints assembled superstring to stdout. Mark executable or run with
`python2 rosalind.py`.


## Caveats

`find_overlap` assumes (without loss of correctness) that left and
right are roughly the same length, but if the left string is
significantly longer, complexity is linear in len(left) but remains
O(min_overlap) if right is significantly longer. Superstring
relationships are not detected.

`adjacency_list` is not technically an adjacency list, whose type
would be `String -> List[String]` rather than `String -> String`. This
is fine for our case, where the path through the graph is acyclic and
unique.

I could return some sort of overlap object/tuple/datastructure that
stores the length of overlap, rather than just a string, so I don't
have to recompute overlap during assembly. I don't for two reasons:

 - find_overlap is only called O(N) times during assembly, vs O(N^2)
   times during adjacency. Not likely to make 1% difference.

 - By not overdesigning for this special-case optimization, code is
   cleaner, more intuitive, and more re-useable.

I call `find_overlap` in `assemble` without first performing a None
check. This is safe, because of the pre-computed `adj`, but the compiler
doesn't know that. Living on the edge! ;)

There are no tests. I tested in the REPL as I went. That said, the
code is pretty modular and easily testable, since I pretty much used
TDD then threw the tests away.

Documentation is just comments with Scala type signatures. Sorry.